# -*- coding: utf-8 -*-

"""
/***************************************************************************

                                 Consolidate Networks QGIS plugin

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-11-15
        copyright            : (C) 2021 by a
        email                : a
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Simon Ducournau'
__date__ = '2021-11-15'
__copyright__ = '(C) 2021 by Simon Ducournau'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import *
import math
from qgis import processing
from qgis.processing import alg

class CalculateDbscan(QgsProcessingAlgorithm):
    """
    Calculate dbscan clusters of lines from a layer source.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )
        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('POINTS_DBSCAN'),
                self.tr('POINTS DBCAN DISTANCE'),
                0.1
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(

                self.tr('DBSCAN*'),
                self.tr('DBSCAN*'),
                False
            )
        )


        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)

        numfeatures = source.featureCount()

        dbscan_ = self.parameterAsBool(parameters, 'DBSCAN*',
                                                context)

        points_dbscan = self.parameterAsDouble(parameters, 'POINTS_DBSCAN',
                                                context)


        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)

        #create points from polylines intersections
        alg_params_pointsalonglines = {

        'DISTANCE': points_dbscan,
        'END_OFFSET': 0,
        'INPUT': outputs['alg_params_unipart']['OUTPUT'],
        'START_OFFSET': 0,
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT


        }
        outputs['alg_params_pointsalonglines'] = processing.run('qgis:pointsalonglines', alg_params_pointsalonglines,context=context, feedback=feedback)


        if feedback.isCanceled():
            return {}

        alg_params_dbscanclustering = {

        'DBSCAN*': dbscan_,
        'EPS': 1,
        'FIELD_NAME': 'CLUSTER_ID',
        'INPUT': outputs['alg_params_pointsalonglines']['OUTPUT'],
        'MIN_SIZE': 5,
        'SIZE_FIELD_NAME': 'CLUSTER_SIZE',
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT



        }
        outputs['alg_params_dbscanclustering'] = processing.run('qgis:dbscanclustering', alg_params_dbscanclustering,context=context, feedback=feedback)

        if feedback.isCanceled():
            return {}


        outputs['alg_params_unipart']['OUTPUT'].dataProvider().createSpatialIndex()
        outputs['alg_params_dbscanclustering']['OUTPUT'].dataProvider().createSpatialIndex()

        alg_params_joinattributesbylocation = {
        'DISCARD_NONMATCHING': False,
        'JOIN_FIELDS': ['CLUSTER_ID','CLUSTER_SIZE'],
        'INPUT': outputs['alg_params_unipart']['OUTPUT'],
        'JOIN': outputs['alg_params_dbscanclustering']['OUTPUT'],
        'PREDICATE': 0,
        'METHOD':2,
        'PREFIX': '',
        'OUTPUT' : QgsProcessing.TEMPORARY_OUTPUT
        }

        outputs['alg_params_joinattributesbylocation'] = processing.run('qgis:joinattributesbylocation', alg_params_joinattributesbylocation,context=context, feedback=feedback)




        layer = outputs['alg_params_joinattributesbylocation']['OUTPUT']


        if feedback.isCanceled():
            return {}
        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, layer.fields(), layer.wkbType(), layer.sourceCrs())
        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'calculatedbscan'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Calculate dbscan clusters of lines from a layer source.'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Consolidate'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CalculateDbscan()


class ConsolidateWithDbscan(QgsProcessingAlgorithm):
    """
    Snap lines to each other splitting by their clusters from a layer source resulted from CalculateDbscan().
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_DBSCAN'),
                self.tr('BUFFER DBSCAN'),
                10.0
            )
        )


        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)

        (sink_output, dest_output) = self.parameterAsSink(
        parameters, self.OUTPUT, context,
        source.fields(), source.wkbType(), source.sourceCrs())


        numfeatures = source.featureCount()


        buffer_snap_dbscan   = self.parameterAsDouble(parameters, 'BUFFER_DBSCAN',
                                                context)


        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)



        layer = outputs['alg_params_unipart']['OUTPUT']


        if feedback.isCanceled():
            return {}


        request = QgsFeatureRequest()
        clause = QgsFeatureRequest().OrderByClause('"CLUSTER_SIZE"', ascending=True)
        orderby = QgsFeatureRequest().OrderBy([clause])
        request.setOrderBy(orderby)


        for y, feature in enumerate(layer.getFeatures(request)):
            if feedback.isCanceled():
                return {}
            if not feature.geometry().isEmpty():
                with edit(layer):


                    geometry = feature.geometry()
                    spatial_index = QgsSpatialIndex(layer.getFeatures())
                    polyline = geometry.asPolyline()
                    seg_start = polyline[0]
                    seg_end = polyline[-1]
                    geometry_start = QgsGeometry.fromPointXY(QgsPointXY(seg_start.x(),seg_start.y()))
                    geometry_end = QgsGeometry.fromPointXY(QgsPointXY(seg_end.x(),seg_end.y()))
                    lastvert = len(polyline)-1




                    nnfeatures_closest_vertex = []
                    nearestids = spatial_index.nearestNeighbor(geometry_start.asPoint(),3,buffer_snap_dbscan)

                    if feature.id() in nearestids:
                        nearestids.remove(feature.id())


                    if len(nearestids) > 0:
                        for nearestid in nearestids:
                            nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))

                            if geometry_start.distance(nnfeature.geometry()) <= buffer_snap_dbscan and feature["CLUSTER_ID"] != nnfeature["CLUSTER_ID"]:
                                nnfeatures_closest_vertex.append((geometry_start.distance(nnfeature.geometry()),nnfeature.geometry().closestVertex(geometry_start.asPoint())))

                        if len(nnfeatures_closest_vertex)  > 0:
                            nnfeatures_closest_vertex.sort(key=lambda k:k[0])
                            nnfeature_closest =  nnfeatures_closest_vertex[0][1]


                            QgsVectorLayerEditUtils(layer).moveVertex(nnfeature_closest[0].x(),nnfeature_closest[0].y(),feature.id(),0)



                    nnfeatures_closest_vertex = []
                    nearestids = spatial_index.nearestNeighbor(geometry_end.asPoint(),3,buffer_snap_dbscan)

                    if feature.id() in nearestids:
                        nearestids.remove(feature.id())


                    if len(nearestids) > 0:
                        for nearestid in nearestids:
                            nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))

                            if geometry_end.distance(nnfeature.geometry()) <= buffer_snap_dbscan and feature["CLUSTER_ID"] != nnfeature["CLUSTER_ID"]:
                                nnfeatures_closest_vertex.append((geometry_end.distance(nnfeature.geometry()),nnfeature.geometry().closestVertex(geometry_end.asPoint())))

                        if len(nnfeatures_closest_vertex)  > 0:
                            nnfeatures_closest_vertex.sort(key=lambda k:k[0])
                            nnfeature_closest =  nnfeatures_closest_vertex[0][1]

                            QgsVectorLayerEditUtils(layer).moveVertex(nnfeature_closest[0].x(),nnfeature_closest[0].y(),feature.id(),lastvert)






                feedback.setProgress(int((y /numfeatures) * 100))

        if feedback.isCanceled():
            return {}

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'consolidatewithdbscan'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Consolidate with DBscan'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Consolidate'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return ConsolidateWithDbscan()

class MakeIntersectionsVertexes(QgsProcessingAlgorithm):
    """
    Insert missing vertices from a source layer.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )


        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_REGION'),
                self.tr('BUFFER REGION'),
                0.3
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))

        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, source.fields(), source.wkbType(), source.sourceCrs())

        numfeatures = source.featureCount()


        buffer_region = self.parameterAsDouble(parameters, 'BUFFER_REGION',
                                                context)


        def insert_vertex_same_length(layer, feature, inter):

            #QgsVectorLayerEditUtils(layer).moveVertex(inter.x(), inter.y(),feature.id(),feature_vertex)

            length = QgsGeometry.length(feature.geometry())
            for i in range(1,4):

                geom_search_same_length = QgsGeometry(feature.geometry())
                geom_search_same_length.insertVertex(inter.x(), inter.y(),feature.geometry().closestVertex(QgsPointXY(inter.x(), inter.y()))[i])
                if QgsGeometry.length(geom_search_same_length) == length:
                    if feature.geometry().closestVertex(QgsPointXY(inter.x(), inter.y()))[i] == -1 and i == 2:
                        vertex = 1
                    elif feature.geometry().closestVertex(QgsPointXY(inter.x(), inter.y()))[i] == -1 and i == 3:
                        vertex = len(feature.geometry().asPolyline())-1
                    else:
                        vertex = feature.geometry().closestVertex(QgsPointXY(inter.x(), inter.y()))[i]
                    QgsVectorLayerEditUtils(layer).insertVertex(inter.x(), inter.y(),feature.id(),vertex)
                    return True


        if feedback.isCanceled():
            return {}

        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)


        layer = outputs['alg_params_unipart']['OUTPUT']

        alg_params_split_lines = {
            'INPUT': layer,
            'LINES': layer,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['alg_params_split_lines'] = processing.run('qgis:splitwithlines', alg_params_split_lines, context=context, feedback=feedback)


        if feedback.isCanceled():
            return {}
        

        #create points from polylines intersections
        # alg_params_extractvertices = {
        # "INPUT": outputs['alg_params_split_lines']['OUTPUT'],
        # 'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        # }
        # outputs['alg_params_extractvertices'] = processing.run('qgis:extractvertices', alg_params_extractvertices, context=context,feedback=feedback)


        # points = outputs['alg_params_extractvertices']['OUTPUT']

        # if feedback.isCanceled():
        #     return {}

        # alg_params_snapgeometries = {
        #     'BEHAVIOR': 1,
        #     'INPUT': layer,
        #     'REFERENCE_LAYER': points,
        #     'TOLERANCE': buffer_region,
        #     'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        # }
        # outputs['alg_params_snapgeometries'] = processing.run('qgis:snapgeometries', alg_params_snapgeometries,context=context, feedback=feedback)

        layer = outputs['alg_params_split_lines']['OUTPUT']

        if feedback.isCanceled():
            return {}

        numfeatures = layer.featureCount()

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'makeintersectionsvertexes'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Make intersections vertexes'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Consolidate'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return MakeIntersectionsVertexes()

class EndpointsStrimmingExtending(QgsProcessingAlgorithm):
    """
    Cut and extend end lines from a layer source.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )
        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_TRIM_EXTEND'),
                self.tr('BUFFER_TRIM_EXTEND'),
                1
            )
        )


        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)


        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, source.fields(), source.wkbType(), source.sourceCrs())

        numfeatures = source.featureCount()


        buffer_trim = self.parameterAsDouble(parameters, 'BUFFER_TRIM_EXTEND',
                                                context)




        if feedback.isCanceled():
            return {}
        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)


        layer = outputs['alg_params_unipart']['OUTPUT']
        request = QgsFeatureRequest()
        #set order by length
        clause = QgsFeatureRequest().OrderByClause('$length', ascending=True)
        orderby = QgsFeatureRequest().OrderBy([clause])
        request.setOrderBy(orderby)


        if feedback.isCanceled():
            return {}

        #trim_&_extend
        for y, feature in enumerate(layer.getFeatures(request)):
            if feedback.isCanceled():
                return {}
            if not feature.geometry().isEmpty():
                with edit(layer):
                    try:

                        geometry = feature.geometry()

                        #layer.select(feature.id())
                        #layer.invertSelection()
                        spatial_index = QgsSpatialIndex(layer.getFeatures())
                        #layer.removeSelection()

                        polyline = geometry.asPolyline()
                        seg_start = polyline[0]
                        seg_start_near_vertex = polyline[1]

                        seg_end = polyline[-1]
                        seg_end_near_vertex = polyline[-2]

                        geometry_start = QgsGeometry.fromPointXY(seg_start)
                        geometry_end = QgsGeometry.fromPointXY(seg_end)

                        lastvert = len(polyline)-1





                        distance = [seg_start.x() - seg_start_near_vertex.x(), seg_start.y() - seg_start_near_vertex.y()]
                        norm = math.sqrt(distance[0] ** 2 + distance[1] ** 2)
                        direction = [distance[0] / norm, distance[1] / norm]
                        start_vector = QgsVector(direction[0] * math.sqrt(2), direction[1] * math.sqrt(2))

                        distance = [seg_end_near_vertex.x() - seg_end.x(), seg_end_near_vertex.y() - seg_end.y()]
                        norm = math.sqrt(distance[0] ** 2 + distance[1] ** 2)
                        direction = [distance[0] / norm, distance[1] / norm]
                        end_vector = QgsVector(direction[0] * math.sqrt(2), direction[1] * math.sqrt(2))

                            #Trimming polyline starting point

                        nearestids = spatial_index.nearestNeighbor(geometry_start.asPoint(),5,buffer_trim)
                        closest_intersections = []
                        if feature.id() in nearestids:
                            nearestids.remove(feature.id())

                        if len(nearestids) > 0:
                            for nearestid in nearestids:
                                nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))
                                nnfeature_closest_vertex = (nnfeature.geometry().closestSegmentWithContext(geometry_start.asPoint()),nnfeature.geometry())

                                if nnfeature_closest_vertex[0][0] <=  buffer_trim**2:

                                    distance = [nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]).x() - nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1).x(), nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]).y() - nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1).y() ]

                                    try:

                                        norm = math.sqrt(distance[0] ** 2 + distance[1] ** 2)
                                        direction = [distance[0] / norm, distance[1] / norm]
                                        nnfeature_vector = QgsVector(direction[0] * math.sqrt(2), direction[1] * math.sqrt(2))


                                        inter = QgsGeometryUtils.lineIntersection(QgsPoint(seg_start),start_vector,nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1),nnfeature_vector)
                                        distance_inter = geometry_start.distance(QgsGeometry.fromPointXY(QgsPointXY(inter[1])))

                                        if inter[0] and distance_inter <= buffer_trim:
                                            closest_intersections.append((inter[1],distance_inter))
                                        else:
                                            inter = QgsGeometryUtils.lineIntersection(QgsPoint(seg_start),start_vector.rotateBy(math.pi),nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1),nnfeature_vector)
                                            distance_inter = geometry_start.distance(QgsGeometry.fromPointXY(QgsPointXY(inter[1])))

                                            if inter[0] and distance_inter <= buffer_trim:
                                                closest_intersections.append((inter[1],distance_inter))
                                    except:
                                        pass

                            if len(closest_intersections) > 0:
                                closest_intersections.sort(key=lambda k:k[1])

                                polyline[0] = QgsPointXY(closest_intersections[0][0])
                                new_geom = QgsGeometry.fromPolylineXY(polyline)
                                if new_geom.length() >= buffer_trim:
                                    feature.setGeometry(new_geom)
                                    layer.updateFeature(feature)










                        nearestids = spatial_index.nearestNeighbor(geometry_end.asPoint(),5,buffer_trim)
                        closest_intersections = []
                        if feature.id() in nearestids:
                            nearestids.remove(feature.id())

                        if len(nearestids) > 0:
                            for nearestid in nearestids:
                                nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))
                                nnfeature_closest_vertex = (nnfeature.geometry().closestSegmentWithContext(geometry_end.asPoint()),nnfeature.geometry())

                                if nnfeature_closest_vertex[0][0] <=  buffer_trim**2:

                                    distance = [nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]).x() - nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1).x(), nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]).y() - nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1).y() ]

                                    try:
                                        norm = math.sqrt(distance[0] ** 2 + distance[1] ** 2)
                                        direction = [distance[0] / norm, distance[1] / norm]
                                        nnfeature_vector = QgsVector(direction[0] * math.sqrt(2), direction[1] * math.sqrt(2))

                                        inter = QgsGeometryUtils.lineIntersection(QgsPoint(seg_end),end_vector,nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1),nnfeature_vector)
                                        distance_inter = geometry_end.distance(QgsGeometry.fromPointXY(QgsPointXY(inter[1])))

                                        if inter[0] and distance_inter <= buffer_trim:
                                            closest_intersections.append((inter[1],distance_inter))
                                        else:
                                            inter = QgsGeometryUtils.lineIntersection(QgsPoint(seg_end),end_vector.rotateBy(math.pi),nnfeature_closest_vertex[1].vertexAt(nnfeature_closest_vertex[0][2]-1),nnfeature_vector)
                                            distance_inter = geometry_end.distance(QgsGeometry.fromPointXY(QgsPointXY(inter[1])))

                                            if inter[0] and distance_inter <= buffer_trim:
                                                closest_intersections.append((inter[1],distance_inter))
                                    except:
                                        pass

                            if len(closest_intersections) > 0:
                                closest_intersections.sort(key=lambda k:k[1])

                                polyline[-1] = QgsPointXY(closest_intersections[0][0])
                                new_geom = QgsGeometry.fromPolylineXY(polyline)
                                if new_geom.length() >= buffer_trim:
                                    feature.setGeometry(new_geom)
                                    layer.updateFeature(feature)

                    except:
                        pass                                    








                    feedback.setProgress(int((y /numfeatures) * 100))

        if feedback.isCanceled():
            return {}

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'endpointstrimmingextending'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Trim and extend endlines from a layer source'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Snapping one layer'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return EndpointsStrimmingExtending()

class EndpointsSnapping(QgsProcessingAlgorithm):
    """
    Snap lines endpoints' to each other's from a layer source
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_SNAPPING'),
                self.tr('BUFFER SNAPPING'),
                1
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))


        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, source.fields(), source.wkbType(), source.sourceCrs())

        numfeatures = source.featureCount()


        buffer_snap = self.parameterAsDouble(parameters, 'BUFFER_SNAPPING',
                                                context)





        if feedback.isCanceled():
            return {}
        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)


        layer = outputs['alg_params_unipart']['OUTPUT']
        request = QgsFeatureRequest()
        #set order by length
        clause = QgsFeatureRequest().OrderByClause('$length', ascending=True)
        orderby = QgsFeatureRequest().OrderBy([clause])
        request.setOrderBy(orderby)


        if feedback.isCanceled():
            return {}

        #trim_&_extend
        for y, feature in enumerate(layer.getFeatures(request)):
            if feedback.isCanceled():
                return {}
            if not feature.geometry().isEmpty():

                with edit(layer):


                    geometry = feature.geometry()

                    #layer.select(feature.id())
                    #layer.invertSelection()
                    spatial_index = QgsSpatialIndex(layer.getFeatures())
                    #layer.removeSelection()

                    polyline = geometry.asPolyline()
                    seg_start = polyline[0]
                    seg_end = polyline[-1]


                    geometry_start = QgsGeometry.fromPointXY(QgsPointXY(seg_start.x(),seg_start.y()))
                    geometry_end = QgsGeometry.fromPointXY(QgsPointXY(seg_end.x(),seg_end.y()))

                    lastvert = len(polyline)-1


                    natural_angle = QgsGeometryUtils.lineAngle(seg_start.x(), seg_start.y(), seg_end.x(), seg_end.y())


                    nnfeatures_closest_vertex = []
                    nearestids = None
                    nearestids = spatial_index.nearestNeighbor(geometry_start.asPoint(),5,buffer_snap)

                    if feature.id() in nearestids:
                        nearestids.remove(feature.id())

                    if len(nearestids) > 0:
                        for nearestid in nearestids:
                            nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))
                            nnfeature_closest_vertex = nnfeature.geometry().closestVertex(geometry_start.asPoint())
                            if nnfeature_closest_vertex[-1] <= buffer_snap and nnfeature_closest_vertex[-1] > 0.0:
                                nnfeatures_closest_vertex.append(nnfeature_closest_vertex)
                        if len(nnfeatures_closest_vertex)  > 0:

                            nnfeatures_closest_vertex.sort(key=lambda k:k[-1])
                            nnfeature_closest =  nnfeatures_closest_vertex[0]

                            polyline[0] = QgsPointXY(nnfeature_closest[0].x(),nnfeature_closest[0].y())
                            new_geom = QgsGeometry.fromPolylineXY(polyline)

                            calculate_angle = QgsGeometryUtils.lineAngle(seg_start.x(), seg_start.y(), nnfeature_closest[0].x(),nnfeature_closest[0].y())

                            if math.degrees(natural_angle) != math.degrees(calculate_angle):
                                         
                                if (math.degrees(calculate_angle)  < (math.degrees(natural_angle) + 90) or math.degrees(calculate_angle)  > (math.degrees(natural_angle) - 90)):
                                    feature.setGeometry(new_geom)
                                    layer.updateFeature(feature)


                    natural_angle = QgsGeometryUtils.lineAngle(seg_end.x(), seg_end.y(), seg_start.x(), seg_start.y())


                    nnfeatures_closest_vertex = []
                    nearestids = None
                    nearestids = spatial_index.nearestNeighbor(geometry_end.asPoint(),5,buffer_snap)

                    if feature.id() in nearestids:
                        nearestids.remove(feature.id())

                    if len(nearestids) > 0:
                        for nearestid in nearestids:
                            nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))
                            nnfeature_closest_vertex = nnfeature.geometry().closestVertex(geometry_end.asPoint())
                            if nnfeature_closest_vertex[-1] <= buffer_snap and nnfeature_closest_vertex[-1] > 0.0:
                                nnfeatures_closest_vertex.append(nnfeature_closest_vertex)
                        if len(nnfeatures_closest_vertex)  > 0:

                            nnfeatures_closest_vertex.sort(key=lambda k:k[-1])
                            nnfeature_closest =  nnfeatures_closest_vertex[0]


                            polyline[-1] = QgsPointXY(nnfeature_closest[0].x(),nnfeature_closest[0].y())
                            new_geom = QgsGeometry.fromPolylineXY(polyline)

                            
                            calculate_angle = QgsGeometryUtils.lineAngle(seg_end.x(), seg_end.y(), nnfeature_closest[0].x(),nnfeature_closest[0].y())
                            
                            if math.degrees(natural_angle) != math.degrees(calculate_angle):
                                       
                                if (math.degrees(calculate_angle)  < (math.degrees(natural_angle) + 90) or math.degrees(calculate_angle)  > (math.degrees(natural_angle) - 90)):
                                    feature.setGeometry(new_geom)
                                    layer.updateFeature(feature)




                feedback.setProgress(int((y /numfeatures) * 100))

        if feedback.isCanceled():
            return {}

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'endpointssnapping'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Snap endpoints to each others from a layer source')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Snapping one layer'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return EndpointsSnapping()

class HubSnapping(QgsProcessingAlgorithm):
    """
    Align lines vertices' hubs on top of each other within a buffer.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'


    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_REGION'),
                self.tr('BUFFER REGION'),
                0.3
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, source.fields(), source.wkbType(), source.sourceCrs())

        numfeatures = source.featureCount()


        buffer_region = self.parameterAsDouble(parameters, 'BUFFER_REGION',
                                                context)




        if feedback.isCanceled():
            return {}

        outputs = {}

        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)


        layer = outputs['alg_params_unipart']['OUTPUT']
        request = QgsFeatureRequest()
        #set order by length
        clause = QgsFeatureRequest().OrderByClause('$length', ascending=False)
        orderby = QgsFeatureRequest().OrderBy([clause])
        request.setOrderBy(orderby)


        if feedback.isCanceled():
            return {}

        #trim_&_extend
        for y, feature in enumerate(layer.getFeatures(request)):
            if feedback.isCanceled():
                return {}
            if not feature.geometry().isEmpty():

                with edit(layer):

                    #layer.select(feature.id())
                    #layer.invertSelection()
                    spatial_index = QgsSpatialIndex(layer.getFeatures())
                    #layer.removeSelection()
                    geometry = feature.geometry()
                    polyline = geometry.asPolyline()
                    seg_start = polyline[0]
           

                    seg_end = polyline[-1]
             

                    geometry_start = QgsGeometry.fromPointXY(QgsPointXY(seg_start.x(),seg_start.y()))
                    geometry_end = QgsGeometry.fromPointXY(QgsPointXY(seg_end.x(),seg_end.y()))

                    lastvert = len(polyline)-1





                    try:
                        nearest_feats_points = []
                        #print('start', feature.id())
                        for feat in layer.getFeatures(QgsFeatureRequest().setFilterRect(geometry_start.buffer(buffer_region,5).boundingBox())):
                            if feat.geometry().closestVertex(geometry_start.asPoint())[-1] <= buffer_region:
                                nearest_feats_points.append((feat.geometry().closestVertex(geometry_start.asPoint()),feat))

                        nearest_feats_points.sort(key=lambda x:x[0][-1])
                        if len(nearest_feats_points) > 2:

                            polygon = QgsGeometry.fromPolygonXY( [[ QgsPointXY( pair[0][0][0], pair[0][0][1] ) for pair in nearest_feats_points ]] )

                            if not polygon.isEmpty():
                                
                                for feat in nearest_feats_points:
                                    QgsVectorLayerEditUtils(layer).moveVertex(polygon.centroid().asPoint().x(),polygon.centroid().asPoint().y(),feat[1].id(),feat[0][1])


                    except:
                        #print("bug_centroid_start", nearest_feats_points)
                        pass


                    try:
                        nearest_feats_points = []

                        #print('end', feature.id())
                        for feat in layer.getFeatures(QgsFeatureRequest().setFilterRect(geometry_end.buffer(buffer_region,5).boundingBox())):
                            if feat.geometry().closestVertex(geometry_end.asPoint())[-1] <= buffer_region:
                                nearest_feats_points.append((feat.geometry().closestVertex(geometry_end.asPoint()),feat))

                        nearest_feats_points.sort(key=lambda x:x[0][-1])
                        if len(nearest_feats_points) > 2:
                            polygon = QgsGeometry.fromPolygonXY( [[ QgsPointXY( pair[0][0][0], pair[0][0][1] ) for pair in nearest_feats_points ]] )

                            if not polygon.isEmpty():
                                
                                for feat in nearest_feats_points:
                                    QgsVectorLayerEditUtils(layer).moveVertex(polygon.centroid().asPoint().x(),polygon.centroid().asPoint().y(),feat[1].id(),feat[0][1])
                                    #edit_vertex_buffer_region(layer, feat[1], feat[1], polygon.centroid().asPoint(),lastvert)


                    except:
                        #print("bug_centroid_end", nearest_feats_points)
                        pass



                    feedback.setProgress(int((y /numfeatures) * 100))

        if feedback.isCanceled():
            return {}

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'hubsnapping'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Snap hubs from a layer source'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Snapping one layer'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return HubSnapping()


class SnapHubsPointsToLayer(QgsProcessingAlgorithm):
    """
    Align lines vertices' hubs on top of a point layer within a buffer.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    REF_INPUT = 'REF_INPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.REF_INPUT,
                self.tr('REF_INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_SNAPPING'),
                self.tr('BUFFER SNAPPING'),
                0.3
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        ref_layer = self.parameterAsSource(parameters, self.REF_INPUT, context)


        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, source.fields(), source.wkbType(), source.sourceCrs())

        numfeatures = source.featureCount()


        buffer_region = self.parameterAsDouble(parameters, 'BUFFER_SNAPPING',
                                                context)

        def takeLast(elem):
            return elem[-1]


        if feedback.isCanceled():
            return {}
        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)


        layer = outputs['alg_params_unipart']['OUTPUT']
        request = QgsFeatureRequest()
        #set order by length
        clause = QgsFeatureRequest().OrderByClause('$length', ascending=False)
        orderby = QgsFeatureRequest().OrderBy([clause])
        request.setOrderBy(orderby)


        if feedback.isCanceled():
            return {}

        #trim_&_extend
        for y, feature in enumerate(layer.getFeatures(request)):
            if feedback.isCanceled():
                return {}
            if not feature.geometry().isEmpty():
                with edit(layer):

                    geometry = feature.geometry()
                    spatial_index = QgsSpatialIndex(layer.getFeatures())
                    polyline = geometry.asPolyline()
                    seg_start = polyline[0]
                    seg_end = polyline[-1]
                    geometry_start = QgsGeometry.fromPointXY(QgsPointXY(seg_start.x(),seg_start.y()))
                    geometry_end = QgsGeometry.fromPointXY(QgsPointXY(seg_end.x(),seg_end.y()))
                    lastvert = len(polyline)-1
                    nearest_point = None
                    nearests_points = []
                    feats = []

                    try:
                        nearest_feats_points = []
                        for feat in ref_layer.getFeatures(QgsFeatureRequest().setFilterRect(QgsGeometry.fromPointXY(QgsPointXY(seg_start.x(),seg_start.y())).buffer(buffer_region,5).boundingBox())):
                            if feat.geometry().closestVertex(seg_start)[-1] <= buffer_region:
                                nearests_points.append(feat.geometry().closestVertex(seg_start))

                        nearest_feats_points.sort(key=lambda x:x[0][-1])
                        if len(nearest_feats_points) > 2:
                      
                            polygon = QgsGeometry.fromPolygonXY( [[ QgsPointXY( pair[0][0][0], pair[0][0][1] ) for pair in nearest_feats_points ]] )

                            if not polygon.isEmpty():
                                    
                                for feat in nearest_feats_points:
                                    QgsVectorLayerEditUtils(layer).moveVertex(polygon.centroid().asPoint().x(),polygon.centroid().asPoint().y(),feat[1].id(),feat[0][1])
                        
                    except:
                        #print("bug_centroid_start", nearest_feats_points)
                        pass


                    try:
                        nearest_feats_points = []

                        #print('end', feature.id())
                        for feat in layer.getFeatures(QgsFeatureRequest().setFilterRect(QgsGeometry.fromPointXY(QgsPointXY(seg_end.x(),seg_end.y())).buffer(buffer_region,5).boundingBox())):
                            if feat.geometry().closestVertex(geometry_end.asPoint())[-1] <= buffer_region:
                                nearest_feats_points.append((feat.geometry().closestVertex(geometry_end.asPoint()),feat))

                        nearest_feats_points.sort(key=lambda x:x[0][-1])
                        if len(nearest_feats_points) > 2:
                            polygon = QgsGeometry.fromPolygonXY( [[ QgsPointXY( pair[0][0][0], pair[0][0][1] ) for pair in nearest_feats_points ]] )

                            if not polygon.isEmpty():
                                
                                for feat in nearest_feats_points:
                                    QgsVectorLayerEditUtils(layer).moveVertex(polygon.centroid().asPoint().x(),polygon.centroid().asPoint().y(),feat[1].id(),feat[0][1])
                                    #edit_vertex_buffer_region(layer, feat[1], feat[1], polygon.centroid().asPoint(),lastvert)


                    except:
                        #print("bug_centroid_end", nearest_feats_points)
                        pass

                    feedback.setProgress(int((y /numfeatures) * 100))

        if feedback.isCanceled():
            return {}

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'snaphubspointstolayer'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Snap hubs points to layer'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Snapping two layers'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return SnapHubsPointsToLayer()

class SnapEndpointsToLayer(QgsProcessingAlgorithm):
    """
    Snap lines endpoints' to each other's from an other layer source.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    REF_INPUT = 'REF_INPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.REF_INPUT,
                self.tr('REF_INPUT'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        self.addParameter(
            QgsProcessingParameterDistance(

                self.tr('BUFFER_REGION'),
                self.tr('BUFFER REGION'),
                10
            )
        )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).



        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('OUTPUT')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.INPUT, context)
        if source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        ref_layer = self.parameterAsSource(parameters, self.REF_INPUT, context)


        (sink_output, dest_output) = self.parameterAsSink(parameters, self.OUTPUT,
                context, source.fields(), source.wkbType(), source.sourceCrs())

        numfeatures = source.featureCount()


        buffer_extrimity = self.parameterAsDouble(parameters, 'BUFFER_REGION',
                                                context)

        def takeLast(elem):
            return elem[-1]


        if feedback.isCanceled():
            return {}
        outputs = {}
        alg_params_unipart = {
        'INPUT': source.materialize(QgsFeatureRequest()),
        'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }


        outputs['alg_params_unipart'] = processing.run("qgis:multiparttosingleparts",alg_params_unipart,context=context,  feedback=feedback)


        layer = outputs['alg_params_unipart']['OUTPUT']
        request = QgsFeatureRequest()
        #set order by length
        clause = QgsFeatureRequest().OrderByClause('$length', ascending=False)
        orderby = QgsFeatureRequest().OrderBy([clause])
        request.setOrderBy(orderby)


        if feedback.isCanceled():
            return {}

        #trim_&_extend
        for y, feature in enumerate(layer.getFeatures(request)):
            if feedback.isCanceled():
                return {}
            if not feature.geometry().isEmpty():
                with edit(layer):

                    geometry = feature.geometry()
                    spatial_index = QgsSpatialIndex(layer.getFeatures())
                    polyline = geometry.asPolyline()
                    seg_start = polyline[0]
                    seg_end = polyline[-1]
                    geometry_start = QgsGeometry.fromPointXY(QgsPointXY(seg_start.x(),seg_start.y()))
                    geometry_end = QgsGeometry.fromPointXY(QgsPointXY(seg_end.x(),seg_end.y()))
                    lastvert = len(polyline)-1
                    nearest_point = None
                    nearests_points = []
                    feats = []

                    natural_angle = QgsGeometryUtils.lineAngle(seg_start.x(), seg_start.y(), seg_end.x(), seg_end.y())


                    nnfeatures_closest_vertex = []
                    nearestids = None
                    nearestids = spatial_index.nearestNeighbor(geometry_start.asPoint(),3,buffer_extrimity)

                    if feature.id() in nearestids:
                        nearestids.remove(feature.id())


                    if len(nearestids) > 0:
                        for nearestid in nearestids:
                            nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))
                            nnfeature_closest_vertex = nnfeature.geometry().closestVertex(geometry_start.asPoint())
                            if nnfeature_closest_vertex[-1] <= buffer_extrimity and nnfeature_closest_vertex[-1] > 0.0:
                                nnfeatures_closest_vertex.append(nnfeature_closest_vertex)

                        if len(nnfeatures_closest_vertex)  > 0:
                            nnfeatures_closest_vertex.sort(key=lambda k:k[-1])
                            nnfeature_closest =  nnfeatures_closest_vertex[0]

                            polyline[0] = QgsPointXY(nnfeature_closest[0].x(),nnfeature_closest[0].y())
                            new_geom = QgsGeometry.fromPolylineXY(polyline)

                            calculate_angle = QgsGeometryUtils.lineAngle(seg_start.x(), seg_start.y(), nnfeature_closest[0].x(),nnfeature_closest[0].y())

                            if math.degrees(natural_angle) != math.degrees(calculate_angle):
                                         
                                if (math.degrees(calculate_angle)  < (math.degrees(natural_angle) + 90) or math.degrees(calculate_angle)  > (math.degrees(natural_angle) - 90)):
                                    feature.setGeometry(new_geom)
                                    layer.updateFeature(feature)


                    natural_angle = QgsGeometryUtils.lineAngle(seg_end.x(), seg_end.y(), seg_start.x(), seg_start.y())

                    nnfeatures_closest_vertex = []
                    nearestids = None
                    nearestids = spatial_index.nearestNeighbor(geometry_end.asPoint(),3,buffer_extrimity)

                    if feature.id() in nearestids:
                        nearestids.remove(feature.id())


                    if len(nearestids) > 0:
                        for nearestid in nearestids:
                            nnfeature = next(layer.getFeatures(QgsFeatureRequest(nearestid)))
                            nnfeature_closest_vertex = nnfeature.geometry().closestVertex(geometry_end.asPoint())
                            if nnfeature_closest_vertex[-1] <= buffer_extrimity and nnfeature_closest_vertex[-1] > 0.0:
                                nnfeatures_closest_vertex.append(nnfeature_closest_vertex)
                        if len(nnfeatures_closest_vertex)  > 0:
                            nnfeatures_closest_vertex.sort(key=lambda k:k[-1])
                            nnfeature_closest =  nnfeatures_closest_vertex[0]


                            polyline[-1] = QgsPointXY(nnfeature_closest[0].x(),nnfeature_closest[0].y())
                            new_geom = QgsGeometry.fromPolylineXY(polyline)

                            
                            calculate_angle = QgsGeometryUtils.lineAngle(seg_end.x(), seg_end.y(), nnfeature_closest[0].x(),nnfeature_closest[0].y())
                            
                            if math.degrees(natural_angle) != math.degrees(calculate_angle):
                                       
                                if (math.degrees(calculate_angle)  < (math.degrees(natural_angle) + 90) or math.degrees(calculate_angle)  > (math.degrees(natural_angle) - 90)):
                                    feature.setGeometry(new_geom)
                                    layer.updateFeature(feature)

                    feedback.setProgress(int((y /numfeatures) * 100))

        if feedback.isCanceled():
            return {}

        for y, feature in enumerate(layer.getFeatures()):
            output_feature = QgsFeature(feature)
            sink_output.addFeature(output_feature, QgsFeatureSink.FastInsert)
            feedback.setProgress(int((y /numfeatures) * 100))
        return {'OUTPUT': self.OUTPUT,
                'NUMBEROFFEATURES': numfeatures}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'snapendpointstoLayer'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return 'Snap endpoints points to layer'

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Snapping two layers'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return SnapEndpointsToLayer()
